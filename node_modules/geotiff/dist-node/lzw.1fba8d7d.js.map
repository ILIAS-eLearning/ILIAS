{"version":3,"sources":["compression/lzw.js"],"names":["MIN_BITS","CLEAR_CODE","EOI_CODE","MAX_BYTELENGTH","getByte","array","position","length","d","a","Math","floor","de","ef","fg","dg","max","console","warn","chunk1","chunks","chunk2","hi","appendReversed","dest","source","i","push","decompress","input","dictionaryIndex","Uint16Array","dictionaryChar","Uint8Array","dictionaryLength","byteLength","initDictionary","getNext","byte","addToDictionary","c","getDictionaryReversed","n","rev","result","code","oldCode","Error","val","oldVal","undefined","LZWDecoder","BaseDecoder","decodeBlock","buffer"],"mappings":"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","file":"lzw.1fba8d7d.js","sourceRoot":"../src","sourcesContent":["import BaseDecoder from './basedecoder';\n\nconst MIN_BITS = 9;\nconst CLEAR_CODE = 256; // clear code\nconst EOI_CODE = 257; // end of information\nconst MAX_BYTELENGTH = 12;\n\nfunction getByte(array, position, length) {\n  const d = position % 8;\n  const a = Math.floor(position / 8);\n  const de = 8 - d;\n  const ef = (position + length) - ((a + 1) * 8);\n  let fg = (8 * (a + 2)) - (position + length);\n  const dg = ((a + 2) * 8) - position;\n  fg = Math.max(0, fg);\n  if (a >= array.length) {\n    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n    return EOI_CODE;\n  }\n  let chunk1 = array[a] & ((2 ** (8 - d)) - 1);\n  chunk1 <<= (length - de);\n  let chunks = chunk1;\n  if (a + 1 < array.length) {\n    let chunk2 = array[a + 1] >>> fg;\n    chunk2 <<= Math.max(0, (length - dg));\n    chunks += chunk2;\n  }\n  if (ef > 8 && a + 2 < array.length) {\n    const hi = ((a + 3) * 8) - (position + length);\n    const chunk3 = array[a + 2] >>> hi;\n    chunks += chunk3;\n  }\n  return chunks;\n}\n\nfunction appendReversed(dest, source) {\n  for (let i = source.length - 1; i >= 0; i--) {\n    dest.push(source[i]);\n  }\n  return dest;\n}\n\nfunction decompress(input) {\n  const dictionaryIndex = new Uint16Array(4093);\n  const dictionaryChar = new Uint8Array(4093);\n  for (let i = 0; i <= 257; i++) {\n    dictionaryIndex[i] = 4096;\n    dictionaryChar[i] = i;\n  }\n  let dictionaryLength = 258;\n  let byteLength = MIN_BITS;\n  let position = 0;\n\n  function initDictionary() {\n    dictionaryLength = 258;\n    byteLength = MIN_BITS;\n  }\n  function getNext(array) {\n    const byte = getByte(array, position, byteLength);\n    position += byteLength;\n    return byte;\n  }\n  function addToDictionary(i, c) {\n    dictionaryChar[dictionaryLength] = c;\n    dictionaryIndex[dictionaryLength] = i;\n    dictionaryLength++;\n    return dictionaryLength - 1;\n  }\n  function getDictionaryReversed(n) {\n    const rev = [];\n    for (let i = n; i !== 4096; i = dictionaryIndex[i]) {\n      rev.push(dictionaryChar[i]);\n    }\n    return rev;\n  }\n\n  const result = [];\n  initDictionary();\n  const array = new Uint8Array(input);\n  let code = getNext(array);\n  let oldCode;\n  while (code !== EOI_CODE) {\n    if (code === CLEAR_CODE) {\n      initDictionary();\n      code = getNext(array);\n      while (code === CLEAR_CODE) {\n        code = getNext(array);\n      }\n\n      if (code === EOI_CODE) {\n        break;\n      } else if (code > CLEAR_CODE) {\n        throw new Error(`corrupted code at scanline ${code}`);\n      } else {\n        const val = getDictionaryReversed(code);\n        appendReversed(result, val);\n        oldCode = code;\n      }\n    } else if (code < dictionaryLength) {\n      const val = getDictionaryReversed(code);\n      appendReversed(result, val);\n      addToDictionary(oldCode, val[val.length - 1]);\n      oldCode = code;\n    } else {\n      const oldVal = getDictionaryReversed(oldCode);\n      if (!oldVal) {\n        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);\n      }\n      appendReversed(result, oldVal);\n      result.push(oldVal[oldVal.length - 1]);\n      addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n      oldCode = code;\n    }\n\n    if (dictionaryLength + 1 >= (2 ** byteLength)) {\n      if (byteLength === MAX_BYTELENGTH) {\n        oldCode = undefined;\n      } else {\n        byteLength++;\n      }\n    }\n    code = getNext(array);\n  }\n  return new Uint8Array(result);\n}\n\nexport default class LZWDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return decompress(buffer, false).buffer;\n  }\n}\n"]}