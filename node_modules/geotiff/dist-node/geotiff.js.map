{"version":3,"sources":["globals.js","rgb.js","../node_modules/parcel-bundler/src/builtins/bundle-url.js","../node_modules/parcel-bundler/src/builtins/bundle-loader.js","compression/index.js","resample.js","geotiffimage.js","dataview64.js","dataslice.js","pool.js","source/httputils.js","source/basesource.js","utils.js","source/blockedsource.js","source/client/base.js","source/client/fetch.js","source/client/xhr.js","source/client/http.js","source/remote.js","source/arraybuffer.js","source/filereader.js","source/file.js","geotiffwriter.js","logging.js","geotiff.js","predictor.js","compression/basedecoder.js","../node_modules/parcel-bundler/src/builtins/loaders/node/js-loader.js"],"names":["fieldTagNames","fieldTags","key","hasOwnProperty","parseInt","fieldTagTypes","arrayFields","BitsPerSample","ExtraSamples","SampleFormat","StripByteCounts","StripOffsets","StripRowCounts","TileByteCounts","TileOffsets","SubIFDs","fieldTypeNames","fieldTypes","photometricInterpretations","WhiteIsZero","BlackIsZero","RGB","Palette","TransparencyMask","CMYK","YCbCr","CIELab","ICCLab","ExtraSamplesValues","Unspecified","Assocalpha","Unassalpha","LercParameters","Version","AddCompression","LercAddCompression","None","Deflate","geoKeyNames","geoKeys","fromWhiteIsZero","raster","max","width","height","rgbRaster","Uint8Array","value","i","j","length","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","c","m","y","k","fromYCbCr","yCbCrRaster","Uint8ClampedArray","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","r","g","b","x","z","Math","min","bundleURL","getBundleURLCached","getBundleURL","Error","err","matches","stack","match","getBaseURL","url","replace","exports","require","loadBundlesLazy","bundles","Array","isArray","id","Promise","resolve","code","LazyPromise","reject","loadBundles","slice","then","all","map","loadBundle","bundleLoaders","registerBundleLoader","type","loader","module","load","register","bundle","substring","lastIndexOf","toLowerCase","bundleLoader","resolved","catch","e","executor","promise","prototype","onSuccess","onError","registry","Map","addDecoder","cases","importFn","forEach","set","getDecoder","fileDirectory","get","Compression","undefined","default","copyNewSize","array","samplesPerPixel","Object","getPrototypeOf","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","newArray","cy","round","cx","lerp","v0","v1","t","resampleBilinear","rawY","yl","floor","yh","ceil","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","GeoTIFFImage","sum","start","end","s","arrayForType","format","bitsPerSample","size","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","needsNormalization","normalizeArray","inBuffer","planarConfiguration","tileWidth","tileHeight","view","DataView","samplesToTransfer","outArray","bitMask","repeat","pixelBitSkip","bitsPerLine","lineBitOffset","pixelBitOffset","bitOffset","outIndex","byteOffset","innerBitOffset","getUint8","getUint16","raw","getUint32","buffer","constructor","dataView","littleEndian","cache","source","tiles","isTiled","PlanarConfiguration","getFileDirectory","getGeoKeys","getWidth","ImageWidth","getHeight","ImageLength","getSamplesPerPixel","SamplesPerPixel","getTileWidth","TileWidth","getTileHeight","TileLength","RowsPerStrip","getBlockWidth","getBlockHeight","getBytesPerPixel","bytes","getSampleByteSize","RangeError","getReaderForSample","sampleIndex","getInt8","getInt16","getInt32","offset","getFloat32","getFloat64","getSampleFormat","getBitsPerSample","getArrayForSample","getTileOrStrip","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","index","byteCount","fetch","request","data","decode","sampleFormat","_readRaster","imageWindow","interleave","resampleMethod","imageWidth","imageHeight","minXTile","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","push","promises","yTile","xTile","si","tile","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","call","windowCoordinate","resampled","readRasters","window","wnd","pool","fillValue","imageWindowWidth","numPixels","apply","fill","result","readRGB","enableAlpha","pi","PhotometricInterpretation","subOptions","ColorMap","red","green","blue","getTiePoints","ModelTiepoint","tiePoints","getGDALMetadata","metadata","GDAL_METADATA","string","items","filter","item","Number","inner","getGDALNoData","GDAL_NODATA","getOrigin","modelTransformation","ModelTransformation","getResolution","referenceImage","modelPixelScale","ModelPixelScale","refResX","refResY","refResZ","pixelIsArea","GTRasterTypeGeoKey","getBoundingBox","origin","resolution","x1","y1","x2","y2","DataView64","arrayBuffer","_dataView","getUint64","left","right","combined","isSafeInteger","getInt64","isNegative","carrying","byte","getFloat16","DataSlice","sliceOffset","bigTiff","_sliceOffset","_littleEndian","_bigTiff","sliceTop","byteLength","covers","readUint8","readInt8","readUint16","readInt16","readUint32","readInt32","readFloat32","readFloat64","readUint64","readInt64","readOffset","Pool","defaultPoolSize","navigator","hardwareConcurrency","worker","Worker","queue","destroy","terminate","CRLFCRLF","itemsToObject","fromEntries","obj","parseHeaders","text","split","line","kv","str","trim","parseContentType","rawContentType","rawParams","params","param","parseContentRange","rawContentRange","total","parseByteRanges","responseArrayBuffer","boundary","decoder","TextDecoder","out","startBoundary","endBoundary","startsWith","innerText","substr","endOfHeaders","indexOf","headers","startOfData","fileSize","BaseSource","slices","fetchSlice","close","assign","target","chunk","iterable","results","lengthOfIterable","chunked","ci","endsWith","expectedEnding","actualEnding","func","invert","oldObj","newObj","range","n","times","numTimes","toArray","toArrayRecursively","input","headerValue","number","unit","first","last","wait","milliseconds","setTimeout","zip","a","A","from","B","AbortError","captureStackTrace","name","CustomAggregateError","errors","message","AggregateError","Block","top","BlockGroup","blockIds","BlockedSource","blockSize","cacheSize","blockCache","LRUCache","blockRequests","blockIdsToFetch","Set","cachedBlocks","missingBlockIds","current","blockId","has","add","fetchBlocks","block","cachedBlock","allSettled","values","some","status","retriedBlockRequests","keys","rejected","reason","aborted","requiredBlocks","readSliceData","groups","groupBlocks","groupRequests","groupIndex","group","blockRequest","response","blockOffset","o","delete","clear","sortedBlockIds","sort","lastBlockId","blocks","blockIdLow","blockIdHigh","sliceData","ArrayBuffer","sliceView","delta","topDelta","blockInnerOffset","usedBlockLength","rangeInnerOffset","blockView","BaseResponse","ok","getHeader","headerName","getData","BaseClient","credentials","FetchResponse","FetchClient","XHRResponse","xhr","getResponseHeader","XHRClient","constructRequest","XMLHttpRequest","open","responseType","entries","setRequestHeader","onload","onerror","onabort","send","abort","addEventListener","HttpResponse","dataPromise","statusCode","HttpClient","parsedUrl","urlMod","parse","httpApi","protocol","http","https","resolveData","chunks","on","Buffer","concat","RemoteSource","client","maxRanges","allowFullFile","_fileSize","fetchSlices","Range","join","byteRanges","others","maybeWrapInBlockedSource","makeFetchSource","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","ArrayBufferSource","makeBufferSource","FileReaderSource","file","blob","FileReader","event","readAsArrayBuffer","makeFileReaderSource","closeAsync","fd","openAsync","path","flags","mode","readAsync","args","read","bytesRead","FileSource","openRequest","alloc","makeFileSource","tagName2Code","geoKeyName2Code","name2code","typeName2byte","numBytesInIfd","_binBE","nextZero","oincr","readUshort","buff","p","readShort","ui8","i16","readInt","i32","readUint","ui32","readASCII","l","String","fromCharCode","readFloat","fl32","readDouble","fl64","writeUshort","writeUint","writeASCII","charCodeAt","writeDouble","_writeIFD","bin","_offset","ifd","eoff","tag","typeName","typeNum","val","num","dlen","toff","encodeIfds","ifds","ifdo","noffs","encodeImage","prfx","img","convertToTids","console","error","metadataDefaults","writeGeotiff","numBands","flattenedValues","rowIndex","columnIndex","bandIndex","GeographicTypeGeoKey","GeogCitationGeoKey","GTModelTypeGeoKey","GeoAsciiParams","geoAsciiParams","toString","GeoKeyDirectory","NumberOfKeys","geoKey","KeyID","Count","TIFFTagLocation","valueOffset","log","encodedMetadata","outputImage","DummyLogger","debug","info","warn","time","timeEnd","LOGGER","setLogger","logger","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","parseGeoKeyDirectory","rawGeoKeyDirectory","geoKeyDirectory","location","count","subarray","getValues","dataSlice","readMethod","fieldTypeLength","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","GeoTIFFBase","options","resX","resY","bbox","firstImage","getImage","usedImage","imageCount","getImageCount","imgBBox","oX","oY","rX","rY","usedBBox","allImages","image","SubfileType","subfileType","NewSubfileType","newSubfileType","imgResX","imgResY","imageResX","imageResY","GeoTIFF","firstIFDOffset","ifdRequests","ghostValues","getSlice","fallbackSize","parseFileDirectoryAt","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","actualOffset","requestIFD","previousIfd","hasNext","getGhostValues","detectionString","heuristicAreaSize","valuesString","metadataSize","fullString","fromSource","headerData","BOM","TypeError","magicNumber","offsetByteSize","MultiGeoTIFF","mainFile","overviewFiles","imageFiles","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","parseFileDirectoriesPerFile","requests","visited","relativeIndex","imageFile","ii","imageCounts","reduce","fromUrl","fromArrayBuffer","fromFile","fromBlob","fromUrls","mainUrl","overviewUrls","writeArrayBuffer","decodeRowAcc","row","stride","decodeRowFloatingPoint","bytesPerSample","wc","copy","applyPredictor","predictor","BaseDecoder","decoded","decodeBlock","Predictor","fs","readFile","__dirname","setImmediate","Function"],"mappings":"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","file":"geotiff.js","sourceRoot":"../src","sourcesContent":["export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nexport const LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nexport const LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n};\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","var bundleURL = null;\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  // Attempt to find the URL of the current script and use that as the base URL\n  try {\n    throw new Error;\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\\/\\/.+)?\\/[^/]+(?:\\?.*)?$/, '$1') + '/';\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\n","var getBundleURL = require('./bundle-url').getBundleURL;\n\nfunction loadBundlesLazy(bundles) {\n  if (!Array.isArray(bundles)) {\n    bundles = [bundles]\n  }\n\n  var id = bundles[bundles.length - 1];\n\n  try {\n    return Promise.resolve(require(id));\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      return new LazyPromise(function (resolve, reject) {\n        loadBundles(bundles.slice(0, -1))\n          .then(function () {\n            return require(id);\n          })\n          .then(resolve, reject);\n      });\n    }\n\n    throw err;\n  }\n}\n\nfunction loadBundles(bundles) {\n  return Promise.all(bundles.map(loadBundle));\n}\n\nvar bundleLoaders = {};\nfunction registerBundleLoader(type, loader) {\n  bundleLoaders[type] = loader;\n}\n\nmodule.exports = exports = loadBundlesLazy;\nexports.load = loadBundles;\nexports.register = registerBundleLoader;\n\nvar bundles = {};\nfunction loadBundle(bundle) {\n  var id;\n  if (Array.isArray(bundle)) {\n    id = bundle[1];\n    bundle = bundle[0];\n  }\n\n  if (bundles[bundle]) {\n    return bundles[bundle];\n  }\n\n  var type = (bundle.substring(bundle.lastIndexOf('.') + 1, bundle.length) || bundle).toLowerCase();\n  var bundleLoader = bundleLoaders[type];\n  if (bundleLoader) {\n    return bundles[bundle] = bundleLoader(getBundleURL() + bundle)\n      .then(function (resolved) {\n        if (resolved) {\n          module.bundle.register(id, resolved);\n        }\n\n        return resolved;\n      }).catch(function(e) {\n        delete bundles[bundle];\n        \n        throw e;\n      });\n  }\n}\n\nfunction LazyPromise(executor) {\n  this.executor = executor;\n  this.promise = null;\n}\n\nLazyPromise.prototype.then = function (onSuccess, onError) {\n  if (this.promise === null) this.promise = new Promise(this.executor)\n  return this.promise.then(onSuccess, onError)\n};\n\nLazyPromise.prototype.catch = function (onError) {\n  if (this.promise === null) this.promise = new Promise(this.executor)\n  return this.promise.catch(onError)\n};\n","const registry = new Map();\n\nexport function addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nexport async function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => import('./raw').then((m) => m.default));\naddDecoder(5, () => import('./lzw').then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => import('./jpeg').then((m) => m.default));\naddDecoder([8, 32946], () => import('./deflate').then((m) => m.default));\naddDecoder(32773, () => import('./packbits').then((m) => m.default));\naddDecoder(34887, () => import('./lerc').then((m) => m.default));\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","import { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute';\nimport findTagsByName from 'xml-utils/find-tags-by-name';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb';\nimport { getDecoder } from './compression';\nimport { resample, resampleInterleaved } from './resample';\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sampleIndex);\n          }\n          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          promises.push(promise);\n          promise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {Object} [options={}] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Array} [options.samples=all samples] the selection of samples to read from.\n   * @param {Boolean} [options.interleave=false] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is\n   *                                 not the same as the images, resampling will be\n   *                                 performed.\n   * @param {number} [options.height] The desired height of the output. When the width\n   *                                  is not the same as the images, resampling will\n   *                                  be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {number|number[]} [options.fillValue] The value to use for parts of the image\n   *                                              outside of the images extent. When\n   *                                              multiple samples are requested, an\n   *                                              array of fill values can be passed.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * greayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {bool} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise.<TypedArray|TypedArray[]>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {Number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample !== null) {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {Number} or null\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array} The bounding box\n   */\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n\n    const x1 = origin[0];\n    const y1 = origin[1];\n\n    const x2 = x1 + (resolution[0] * this.getWidth());\n    const y2 = y1 + (resolution[1] * this.getHeight());\n\n    return [\n      Math.min(x1, x2),\n      Math.min(y1, y2),\n      Math.max(x1, x2),\n      Math.max(y1, y2),\n    ];\n  }\n}\n\nexport default GeoTIFFImage;\n","import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","import { Pool as tPool, spawn, Worker, Transfer } from 'threads';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency : null;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} size The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {Worker} worker The decoder worker, loaded and initialised. Enables\n   *                        loading the worker using worker-loader(or others) externally\n   *                        when using this library as a webpack dependency.\n   */\n  constructor(size = defaultPoolSize, worker = new Worker('./decoder.worker.js')) {\n    this.pool = tPool(() => spawn(worker), size);\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise.<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    return new Promise((resolve, reject) => {\n      this.pool.queue(async (decode) => {\n        try {\n          const data = await decode(fileDirectory, Transfer(buffer));\n          resolve(data);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    });\n  }\n\n  destroy() {\n    this.pool.terminate(true);\n  }\n}\n\nexport default Pool;\n","const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n","/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n","import LRUCache from 'lru-cache';\nimport { BaseSource } from './basesource';\nimport { AbortError, AggregateError, wait, zip } from '../utils';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new LRUCache({ max: cacheSize });\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {basesource/Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const cachedBlocks = new Map();\n    const blockRequests = new Map();\n    const missingBlockIds = new Set();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      // chunk the current slice into blocks\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        // check if the block is cached, being requested or still missing\n        const blockId = Math.floor(current / this.blockSize);\n\n        if (this.blockCache.has(blockId)) {\n          cachedBlocks.set(blockId, this.blockCache.get(blockId));\n        } else if (this.blockRequests.has(blockId)) {\n          blockRequests.set(blockId, this.blockRequests.get(blockId));\n        } else if (this.blockIdsToFetch.has(blockId)) {\n          missingBlockIds.add(blockId);\n        } else {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.add(blockId);\n        }\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    for (const blockId of missingBlockIds) {\n      const block = this.blockRequests.get(blockId);\n      const cachedBlock = this.blockCache.get(blockId);\n\n      if (block) {\n        blockRequests.set(blockId, block);\n      } else if (cachedBlock) {\n        cachedBlocks.set(blockId, cachedBlock);\n      } else {\n        throw new Error(`Block ${blockId} is not in the block requests`);\n      }\n    }\n\n    // actually await all pending requests\n    let results = await Promise.allSettled(Array.from(blockRequests.values()));\n\n    // perform retries if a block was interrupted by a previous signal\n    if (results.some((result) => result.status === 'rejected')) {\n      const retriedBlockRequests = new Set();\n      for (const [blockId, result] of zip(blockRequests.keys(), results)) {\n        const { rejected, reason } = result;\n        if (rejected) {\n          // push some blocks back to the to-fetch list if they were\n          // aborted, but only when a different signal was used\n          if (reason.name === 'AbortError' && reason.signal !== signal) {\n            this.blockIdsToFetch.add(blockId);\n            retriedBlockRequests.add(blockId);\n          }\n        }\n      }\n\n      // start the retry of some blocks if required\n      if (this.blockIdsToFetch.length > 0) {\n        this.fetchBlocks(signal);\n        for (const blockId of retriedBlockRequests) {\n          const block = this.blockRequests.get(blockId);\n          if (!block) {\n            throw new Error(`Block ${blockId} is not in the block requests`);\n          }\n          blockRequests.set(blockId, block);\n        }\n        results = await Promise.allSettled(Array.from(blockRequests.values()));\n      }\n    }\n\n    // throw an error (either abort error or AggregateError if no abort was done)\n    if (results.some((result) => result.status === 'rejected')) {\n      if (signal && signal.aborted) {\n        throw new AbortError('Request was aborted');\n      }\n      throw new AggregateError(\n        results.filter((result) => result.status === 'rejected').map((result) => result.reason),\n        'Request failed',\n      );\n    }\n\n    // extract the actual block responses\n    const values = results.map((result) => result.value);\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(Array.from(blockRequests.keys()), values));\n    for (const [blockId, block] of cachedBlocks) {\n      requiredBlocks.set(blockId, block);\n    }\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          const blockRequest = (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n              );\n              this.blockCache.set(blockId, block);\n              return block;\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n              }\n              throw err;\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })();\n          this.blockRequests.set(blockId, blockRequest);\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      const top = slice.offset + slice.length;\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor((slice.offset + slice.length) / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n","export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {object} [options]\n   */\n  async request({ headers, credentials, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n","import { BaseClient, BaseResponse } from './base';\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  async request({ headers, credentials, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n","import { BaseClient, BaseResponse } from './base';\nimport { AbortError } from '../../utils';\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base';\nimport { AbortError } from '../../utils';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { parseByteRanges, parseContentRange, parseContentType } from './httputils';\nimport { BaseSource } from './basesource';\nimport { BlockedSource } from './blockedsource';\n\nimport { FetchClient } from './client/fetch';\nimport { XHRClient } from './client/xhr';\nimport { HttpClient } from './client/http';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return onyl the first\n\n        // get the rest of the slices and fetch them iteratetively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, blockSize, cacheSize);\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n","import { BaseSource } from './basesource';\nimport { AbortError } from '../utils';\n\nclass ArrayBufferSource extends BaseSource {\n  constructor(arrayBuffer) {\n    super();\n    this.arrayBuffer = arrayBuffer;\n  }\n\n  fetchSlice(slice, signal) {\n    if (signal && signal.aborted) {\n      throw new AbortError('Request aborted');\n    }\n    return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);\n  }\n}\n\nexport function makeBufferSource(arrayBuffer) {\n  return new ArrayBufferSource(arrayBuffer);\n}\n","import { BaseSource } from './basesource';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n","import fs from 'fs';\nimport { BaseSource } from './basesource';\n\nfunction closeAsync(fd) {\n  return new Promise((resolve, reject) => {\n    fs.close(fd, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction openAsync(path, flags, mode = undefined) {\n  return new Promise((resolve, reject) => {\n    fs.open(path, flags, mode, (err, fd) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(fd);\n      }\n    });\n  });\n}\n\nfunction readAsync(...args) {\n  return new Promise((resolve, reject) => {\n    fs.read(...args, (err, bytesRead, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ bytesRead, buffer });\n      }\n    });\n  });\n}\n\nclass FileSource extends BaseSource {\n  constructor(path) {\n    super();\n    this.path = path;\n    this.openRequest = openAsync(path, 'r');\n  }\n\n  async fetchSlice(slice) {\n    // TODO: use `signal`\n    const fd = await this.openRequest;\n    const { buffer } = await readAsync(\n      fd,\n      Buffer.alloc(slice.length),\n      0,\n      slice.length,\n      slice.offset,\n    );\n    return buffer.buffer;\n  }\n\n  async close() {\n    const fd = await this.openRequest;\n    await closeAsync(fd);\n  }\n}\n\nexport function makeFileSource(path) {\n  return new FileSource(path);\n}\n","/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals';\nimport { assign, endsWith, forEach, invert, times } from './utils';\n\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  times(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, (rowIndex) => {\n      times(width, (columnIndex) => {\n        times(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => endsWith(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey in geoKeys) {\n    if (geoKeys.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n","/**\n * A no-op logger\n */\nclass DummyLogger {\n  log() {}\n\n  debug() {}\n\n  info() {}\n\n  warn() {}\n\n  error() {}\n\n  time() {}\n\n  timeEnd() {}\n}\n\nlet LOGGER = new DummyLogger();\n\n/**\n *\n * @param {object} logger the new logger. e.g `console`\n */\nexport function setLogger(logger = new DummyLogger()) {\n  LOGGER = logger;\n}\n\nexport function debug(...args) {\n  return LOGGER.debug(...args);\n}\n\nexport function log(...args) {\n  return LOGGER.log(...args);\n}\n\nexport function info(...args) {\n  return LOGGER.info(...args);\n}\n\nexport function warn(...args) {\n  return LOGGER.warn(...args);\n}\n\nexport function error(...args) {\n  return LOGGER.error(...args);\n}\n\nexport function time(...args) {\n  return LOGGER.time(...args);\n}\n\nexport function timeEnd(...args) {\n  return LOGGER.timeEnd(...args);\n}\n","import GeoTIFFImage from './geotiffimage';\nimport DataView64 from './dataview64';\nimport DataSlice from './dataslice';\nimport Pool from './pool';\n\nimport { makeRemoteSource } from './source/remote';\nimport { makeBufferSource } from './source/arraybuffer';\nimport { makeFileReaderSource } from './source/filereader';\nimport { makeFileSource } from './source/file';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals';\nimport { writeGeotiff } from './geotiffwriter';\nimport * as globals from './globals';\nimport * as rgb from './rgb';\nimport { getDecoder, addDecoder } from './compression';\nimport { setLogger } from './logging';\n\nexport { globals };\nexport { rgb };\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {Object} [options={}] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Array} [options.bbox=whole image] the subset to read data from in\n   *                                           geographical coordinates.\n   * @param {Array} [options.samples=all samples] the selection of samples to read from.\n   * @param {Boolean} [options.interleave=false] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {Number} [options.width] The desired width of the output. When the width is not the\n   *                                 same as the images, resampling will be performed.\n   * @param {Number} [options.height] The desired height of the output. When the width is not the\n   *                                  same as the images, resampling will be performed.\n   * @param {String} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @param {Number|Number[]} [options.fillValue] The value to use for parts of the image\n   *                                              outside of the images extent. When multiple\n   *                                              samples are requested, an array of fill values\n   *                                              can be passed.\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {Source} source The datasource to read from.\n   * @param {Boolean} littleEndian Whether the image uses little endian.\n   * @param {Boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {Number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {Object} [options] further options.\n   * @param {Boolean} [options.cache=false] whether or not decoded tiles shall be cached.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {ImageFileDirectory} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {Number} [index=0] the index of the image to return.\n   * @returns {GeoTIFFImage} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Number} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Object} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {source~Source} source The source of data to parse from.\n   * @param {object} options Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {Number} [index=0] the index of the image to return.\n   * @returns {GeoTIFFImage} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Number} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport async function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\n","function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n","import { applyPredictor } from '../predictor';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n","var fs = require('fs');\n\nmodule.exports = function loadJSBundle(bundle) {\n  return new Promise(function(resolve, reject) {\n    fs.readFile(__dirname + bundle, 'utf8', function(err, data) {\n      if (err) {\n        reject(err);\n      } else {\n        // wait for the next event loop iteration, so we are sure\n        // the current module is fully loaded\n        setImmediate(function() {\n          resolve(data);\n        });\n      }\n    });\n  })\n  .then(function(code) {\n    new Function('', code)();\n  });\n};\n"]}